* front.c - a lexical analyzer system for simple
arithmetic expressions */
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <cstring.h>
/* Global declarations */
/* Variables */
int charClass;
char lexeme[100];
char nextChar;
int lexLen;
int token;
int nextToken;
FILE *in_fp;
/* Function declarations */
int lookup(char ch);
void addChar(void);
void getChar(void);
void getNonBlank(void);
int lex(void);
void expr(void);
void term(void);
void factor(void);
void error2(void);
char KEYWORDS[] = {"switch", "for", "while", "and "};
/* Character classes */
#define LETTER 0
#define DIGIT 1
#define UNKNOWN 99
/* Token codes */
#define FLOAT_LIT 9
#define INT_LIT 10
#define IDENT 11
#define ASSIGN_OP 20
#define ADD_OP 21
#define SUB_OP 22
#define MULT_OP 23
#define DIV_OP 24
#define LEFT_PAREN 25
#define RIGHT_PAREN 26
#define MOD_OP 27
#define COMMA 28
#define SEMICOLON 29
#define LEFT_BRACK 30
#define RIGHT_BRACK 31
#define DOT 32
#define LESS_THAN 33
#define GREATER_THAN 34
#define LESS_THAN_EQUAL 35
#define GREATER_THAN_EQUAL 36
#define IF_CODE 37
#define ELSE_CODE 38
/**
ifstmt
Parses strings in the language generated by the rule:
<ifstmt> -> if (<boolexpr>) <statement>
[else <statement>]
**/
/******************************************************/
/* main driver */
int main(void) {
/* Open the input data file and process its contents */
if ((in_fp = fopen("front.in", "r")) == NULL)
printf("ERROR - cannot open front.in \n");
else {
getChar();
do {
lex();
} while (nextToken != EOF);
}
if ((in_fp = fopen("front.in", "r")) == NULL)
printf("ERROR - cannot open front.in \n");
else {
getChar();
lex();
expr();
}
// return 0;
return 0;
}
/******************************************************/
/* lookup - a function to look up operators and
parentheses and return the token */
int lookup(char ch) {
// == cant be passed in
// <=
switch (ch) {
case '(':
addChar();
nextToken = LEFT_PAREN;
break;
case ')':
addChar();
nextToken = RIGHT_PAREN;
break;
case '+':
addChar();
nextToken = ADD_OP;
break;
case '-':
addChar();
nextToken = SUB_OP;
break;
case '*':
addChar();
nextToken = MULT_OP;
break;
case '/':
addChar();
nextToken = DIV_OP;
break;
case '=':
addChar();
nextToken = ASSIGN_OP;
break;
case '%':
addChar();
nextToken = MOD_OP;
break;
case ';':
addChar();
nextToken = SEMICOLON;
break;
case ',':
addChar();
nextToken = COMMA;
break;
case '{':
addChar();
nextToken = LEFT_BRACK;
break;
case '}':
addChar();
nextToken = RIGHT_BRACK;
break;
case '.':
addChar();
nextToken = DOT;
break;
case '<':
addChar();
nextToken = LESS_THAN;
break;
case '>':
addChar();
nextToken = GREATER_THAN;
break;
default:
addChar();
nextToken = EOF;
break;
}
return nextToken;
}
/******************************************************/
/* addChar - a function to add nextChar to lexeme */
void addChar(void) {
if (lexLen <= 98) {
lexeme[lexLen++] = nextChar;
lexeme[lexLen] = '\0';
} else
printf("Error - lexeme is too long \n");
}
/******************************************************/
/* getChar - a function to get the next character of
input and determine its character class
This language transitions on every possible character
*/
void getChar(void) {
if ((nextChar = getc(in_fp)) != EOF) {
if (isalpha(nextChar))
/// (nextChar >= 65 && nextChar <= 90 ) ||
/// (nextChar >= 97 && nextChar <= 122) ||
charClass = LETTER;
else if (isdigit(nextChar))
/// (nextChar >= 48 && nextChar <= 57) ||
charClass = DIGIT;
else
charClass = UNKNOWN;
} else
charClass = EOF;
}
/******************************************************/
/* getNonBlank - a function to call getChar until it
returns a non-whitespace character */
void getNonBlank(void) {
while (isspace(nextChar))
getChar();
}
/******************************************************/
/* lex - a simple lexical analyzer for arithmetic
expressions */
int x;
int lex(void) {
lexLen = 0;
getNonBlank();
int x;
switch (charClass) {
/* Identifiers */
/* [a-zA-Z][a-zA-Z0-9]* is the regular expression for an identifier */
case LETTER:
addChar();
getChar();
while (charClass == LETTER || charClass == DIGIT) {
addChar();
getChar();
}
nextToken = IDENT;
break;
/* Integer literals */
/* [0-9]+ is the regular expression for an integer */
/* [0-9]*.[0-9]+[f|d]? is the regular expression for an FLOAT_LIT */
// .0
// 0.0
// 0.0324f
// 0.0324d
//// 8978176728 sadghsajg326173821
case DIGIT:
addChar();
getChar();
while (charClass == DIGIT) {
addChar();
getChar();
}
if (nextChar != '.') {
nextToken = INT_LIT;
} else {
addChar();
getChar();
while (charClass == DIGIT) {
addChar();
getChar();
}
if (nextChar == 'd' || nextChar == 'f') {
addChar();
getChar();
}
nextToken = FLOAT_LIT;
}
break;
/* Parentheses and operators */
/* ^[a-zA-Z0-9] is the regular expression for an special charater */
case UNKNOWN:
if (nextChar == '.') {
addChar();
getChar();
if (charClass == DIGIT) {
while (charClass == DIGIT) {
addChar();
getChar();
}
if (nextChar == 'd' || nextChar == 'f') {
addChar();
getChar();
}
nextToken = FLOAT_LIT;
}
nextToken = DOT;
} else {
lookup(nextChar);
getChar();
if (nextToken == LESS_THAN && nextChar == '=') {
addChar();
getChar();
nextToken = LESS_THAN_EQUAL;
} else if (nextToken == GREATER_THAN && nextChar == '=') {
addChar();
getChar();
nextToken = GREATER_THAN_EQUAL;
}
}
break;
/* EOF */
case EOF:
nextToken = EOF;
lexeme[0] = 'E';
lexeme[1] = 'O';
lexeme[2] = 'F';
lexeme[3] = '\0';
break;
} /* End of switch */
printf("Next token is: %d, Next lexeme is %s\n", nextToken, lexeme);
return nextToken;
} /* End of function lex */
void expr(void) {
printf("Enter <expr>\n");
/* Parse the first term */
term();
/* As long as the next token is + or -, get
the next token and parse the next term */
while (nextToken == ADD_OP || nextToken == SUB_OP) {
lex();
term();
}
printf("Exit <expr>\n");
}
/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | / | % ) <factor>}
*/
void term(void) {
printf("Enter <term>\n");
/* Parse the first factor */
factor();
/* As long as the next token is * or /, get the
next token and parse the next factor */
while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP) {
lex();
factor();
}
printf("Exit <term>\n");
}
/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | float_constant | ( <expr> )
*/
void factor(void) {
printf("Enter <factor>\n");
/* Determine which RHS */
if (nextToken == IDENT || nextToken == INT_LIT || nextToken == FLOAT_LIT)
/* Get the next token */
lex();
/* If the RHS is ( <expr> ), call lex to pass over the
left parenthesis, call expr, and check for the right
parenthesis */
else {
if (nextToken == LEFT_PAREN) {
lex();
expr();
if (nextToken == RIGHT_PAREN)
lex();
else {
error2();
}
}
/* It was not an id, an integer literal, or a left
parenthesis */
else
error2();
}
printf("Exit <factor>\n");
}
void error2(char *str) {
printf("ERROR STOP");
exit(0);
}
/// 1 2 3 4 5 6 7
/*
Pre(){
Print(node)
Pre(node.left)
Pre(node.right)
}
In(){
In(node.left)
Print(node)
In(node.right)
}
Post(){
Post(node.left)
Post(node.right)
Print(node)
}
*/
String allMyStuff;
String lexeme = "";
String whatNumber() {
enum numberState { a, b, int1, float1, float2 } current;
current = a;
int place = 0;
String lexeme = "";
while (1) {
switch (current) {
case a:
if (allMyStuff[place] == ".")
lexeme += allMyStuff[place] current = b;
else if (isDigit(allMyStuff[place]) {
current = int1;
} else {
return 0;
}
break;
}
}
}