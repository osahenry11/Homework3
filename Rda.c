#include "main.c"
/*
E -> E + T | E - T | T
T -> T * F | T / F | T % F | F
F -> id | int_constant | ( E )
<expr> -> <term> {(+ | -) <term>}
<term> -> <factor> {(* | / | % ) <factor>}
<factor> -> id | int_constant | '(' <expr> ')'
LL Grammars
Read the input from left to right
Left Most Derivation
Left hand recursion direct or in direct
Must past pairwise disjointness test.
*/
/* expr
Parses strings in the language generated by the rule:
<expr> -> <term> {(+ | -) <term>} // reason for eBNF to elminate left hand recrussion
<expr> -> <expr> + <term>
*/
void expr1(void){
printf("Enter<expr>\n");
term();
while (nextToken == ADD_OP || nextToken == SUB_OP){
lex(); // Get the next token
term();
}
printf("Exit<expr>\n");
}
/* term
Parses strings in the language generated by the rule:
<term> -> <factor> {(* | / | % ) <factor>}
*/
void term1(void){
printf("Enter<term>\n");
factor();
while (nextToken == MULT_OP || nextToken == DIV_OP|| nextToken == MOD_OP){
lex(); // Get the next token
factor();
}
printf("Exit<term>\n");
}
/* factor
Parses strings in the language generated by the rule:
<factor> -> id | int_constant | ( <expr> )
*/
void factor1(void){
if (nextToken == IDENT){
lex();
} else if (nextToken == INT_LIT ){
lex();
} else if ( nextToken == LEFT_PAREN){
lex();
expr();
if ( nextToken == RIGHT_PAREN){
lex();
} else{
error();
}
} else {
error();
}
}
/****
Trace of the parse of a + b * c:
Next token is: 11, Next lexeme is a
Enter <expr>
Enter <term>
Enter <factor>
Next token is: 21, Next lexeme is +
Exit <factor>
Exit <term>
Next token is: 11, Next lexeme is b
Enter <term>
Enter <factor>
Next token is: 23, Next lexeme is *
Exit <factor>
Next token is: 11, Next lexeme is c
Enter <factor>
Next token is: -1, Next lexeme is EOF
Exit <factor>
Exit <term>
Exit <expr>
****/
/****
Trace of the parse of a * (b + c):
Next token is: 11, Next lexeme is a
Enter <expr>
Enter <term>
Enter <factor>
Next token is: 23, Next lexeme is *
Exit <factor>
Next token is: 25, Next lexeme is (
Enter <factor>
Next token is: 11, Next lexeme is b
Enter <expr>
Enter <term>
Enter <factor>
Next token is: 21, Next lexeme is +
Exit <factor>
Exit <term>
Next token is: 11, Next lexeme is c
Enter <term>
Enter <factor>
Next token is: 26 , Next lexeme is )
Exit <factor>
Exit <term>
Exit <expr>
Next token is: -1, Next lexeme is EOF
Exit <factor>
Exit <term>
Exit <expr>
****/
/**
ifstmt
Parses strings in the language generated by the rule:
<ifstmt> -> if `(`<boolexpr>`)` <statement>
[else <statement>]
**/
void boolexpr(void);
void statement(void);
void ifstmt(void){
if (nextToken == IF_CODE){
lex();
if (nextToken == LEFT_PAREN){
lex();
boolexpr();
if (nextToken == RIGHT_PAREN){
lex();
statement();
if (nextToken == ELSE_CODE){
lex();
statement();
}
} else {
error();
}
} else {
error();
}
} else {
error();
}
}
